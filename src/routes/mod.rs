mod misc;
mod event;
mod member;
mod officers;

use crate::error::{GreaseError, GreaseResult};
use crate::extract::Extract;
use http::{
    header::{CONTENT_LENGTH, CONTENT_TYPE},
    response,
};
use serde::{Deserialize, Serialize};
use serde_json::Value;
use self::misc::*;
use self::event::*;
use self::member::*;
use self::officers::*;

#[macro_export]
macro_rules! check_for_permission {
    ($user:expr => $permission:expr) => {
        if !$user.permissions.contains(&crate::db::models::member::MemberPermission {
            name: $permission.to_owned(),
            event_type: None,
        }) {
            return Err(GreaseError::Forbidden(Some($permission.to_owned())));
        }
    };
    ($user:expr => $permission:expr; $event_type:expr) => {
        if !$user.permissions.contains(&crate::db::models::member::MemberPermission {
            permission: $permission.to_owned(),
            event_type: Some($event_type.to_owned()),
        }) {
            return Err(GreaseError::Forbidden($permission.to_owned()));
        }
    };
}

macro_rules! handle_routes {
    ($request:expr, $uri:expr, $given_method:expr => [ $($methods:ident $routes:ty => $handlers:ident, )* ] ) => {
        {
            $(if $given_method == stringify!($method) {
                if let Some(data) = $uri.parse::<$routes>().or(format!("{}?", $uri).parse::<$routes>()).ok() {
                    return $handlers(data, Extract::extract(&$request)?);
                }
            })*
            Err(GreaseError::NotFound)
        }
    };
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///
///
/// TODO: find dependencies using libc that mess up static compile... (PROBABLY UUID)
///
///
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

pub fn handle_request(request: cgi::Request) -> cgi::Response {
    let uri = request
        .headers()
        .get("x-cgi-path-info")
        .map(|uri| uri.to_str().unwrap())
        .unwrap_or("")
        .to_string();
    let method = request.method().to_string();

    match route_request(request, uri, method) {
        Ok(value) => {
            let body = value.to_string().into_bytes();
            response::Builder::new()
                .status(200)
                .header(CONTENT_TYPE, "application/json")
                .header(CONTENT_LENGTH, body.len().to_string().as_str())
                .body(body)
                .unwrap()
        }
        Err(error) => error.as_response(),
    }
}

fn route_request(request: cgi::Request, uri: String, method: String) -> GreaseResult<Value> {
    handle_routes!(request, uri, method => [
        GET  LoginRequest  => login,
        GET  LogoutRequest => logout,
        GET  MembersRequest => get_members,
        GET  EventsRequest  => get_events,
        GET  GetVariableRequest => get_variable,
        POST SetVariableRequest => set_variable,
        GET  AnnouncementsRequest   => get_announcements,
        POST NewAnnouncementRequest => make_new_announcement,
        GET  GoogleDocsRequest => get_google_docs,
        POST GoogleDocsRequest => modify_google_docs,
    ])
}

#[derive(Debug, Serialize, Deserialize)]
pub struct OptionalEmailQuery {
    email: Option<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct OptionalIdQuery {
    id: Option<i32>,
}

#[derive(PartialEq)]
pub enum Method {
    Get,
    Post,
}

impl Extract for Method {
    fn extract(request: &cgi::Request) -> GreaseResult<Self> {
        match request.method().to_string().as_str() {
            "GET" => Ok(Method::Get),
            "POST" => Ok(Method::Post),
            _other => Err(GreaseError::InvalidMethod),
        }
    }
}

// AbsenceRequest
// ActiveSemester
// Announcement
// Attendance
// Carpool
// Event
// EventType
// Fee
// Gig
// GigRequest
// GigSong
// GoogleDoc
// MediaType
// Member
// MemberRole
// MeetingMinutes
// Outfit
// OutfitBorrow
// Permission
// RidesIn
// Role
// RolePermission
// SectionType
// Semester
// Session
// Song
// SongLink
// Todo
// Transaction
// TransactionType
// Uniform
